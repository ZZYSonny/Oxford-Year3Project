include "../common.csp"

NTock=3
instance Monitor=ModuleMonitor(TypeThread)
instance VarNanoTime=ModuleVariable({0..NTock},0)
instance VarData=ModuleUninitVariable(TypeData)
instance VarFull=ModuleVariable(Bool,False)
instance VarConsumed=ModuleVariable(Bool,True)

waitUntil(me,end)=
  Monitor::wait(me) ||| (
    VarNanoTime::getValue?now:{end..NTock} ->
    Monitor::WaitTimeout!me ->
    SKIP
  )

whileWaitUntil(me,end,cond)=
  while(cond)(waitUntil(me,end);SKIP)

clock(now)= 
  tock -> 
  VarNanoTime::setValue!(now+1)->
  if(now!=NTock) then clock(now+1) else STOP

sendWithin(me,x,duration)=
  --synchronized
  Monitor::enter(me);
  --val start = nanoTime
  VarNanoTime::getValue?start ->
  --val end = start+durationNS
  let end=start+duration within
  --while(full && nanoTime-start < durationNS) 
  --  waitUntil(end)
  whileWaitUntil(me,end,\ktrue,kfalse @
    VarFull::getValue?full ->
    VarNanoTime::getValue?now ->
    if full and now<end then ktrue else kfalse
  );
  --if(full)
  VarFull::getValue?full1 ->
  if full1 then(
    --assert(nanoTime-start >= durationNS); false
    SKIP
  )else(
    --data = x;
    VarData::setValue!x ->
    --full = true; 
    VarFull::setValue!True ->
    --consumed = false;
    VarConsumed::setValue!False ->
    --notifyAll()
    Monitor::notifyAll(me);
    --while(!consumed && nanoTime-start <  durationNS) 
    --    waitUntil(end)
    whileWaitUntil(me,end,\ktrue,kfalse @
      VarConsumed::getValue?consumed ->
      VarNanoTime::getValue?now ->
      if not consumed and now<end then ktrue else kfalse
    );
    --if(!consumed)
    VarConsumed::getValue?consumed1 ->
    if consumed1 then (
      --assert(nanoTime-start >= durationNS);
      --consumed = true 
      VarConsumed::setValue!True ->
      --full = false;
      VarFull::setValue!False ->
      --notifyAll();
      Monitor::notifyAll(me)
      --false
    )else(
      --full = false;
      VarFull::setValue!False ->
      --notifyAll();
      Monitor::notifyAll(me)
      --true 
    )
  );SKIP