include "../common.csp"

instance Monitor=ModuleMonitor(TypeThread)
instance VarNanoTime=ModuleVariable({0..NTock},0)
instance VarData=ModuleUninitVariable(TypeData)
instance VarFull=ModuleVariable(Bool,False)
instance VarConsumed=ModuleVariable(Bool,True)

waitUntil(me,end)=
  Monitor::wait(me) ||| (
    VarNanoTime::getValue?now:{end..NTock} ->
    Monitor::WaitTimeout!me ->
    SKIP
  )

whileWaitUntil(me,end,cond)=
  while(cond)(waitUntil(me,end);SKIP)

clock(now)= 
  if(now+1>NTock) then STOP else
    VarNanoTime::setValue!(now+1)->
    tock -> 
    clock(now+1)

channel Call: TypeThread.CallParam
channel Return: TypeThread.ReturnParam

sendWithin(me,x,duration)=
  Call!me!(SendParam.x.duration) ->
  --synchronized
  Monitor::enter(me);
  --val start = nanoTime
  VarNanoTime::getValue?start ->
  --val end = start+durationNS
  let end=start+duration within
  --while(full && nanoTime-start < durationNS) 
  --  waitUntil(end)
  whileWaitUntil(me,end,\ktrue,kfalse @
    VarFull::getValue?full ->
    VarNanoTime::getValue?now ->
    if full and now<end then ktrue else kfalse
  );
  --if(full)
  VarFull::getValue?full1 ->
  if full1 then(
    --assert(nanoTime-start >= durationNS);
    --false
    Return!me!(SendReturn.False) ->
    SKIP
  )else(
    --data = x;
    VarData::setValue!x ->
    --full = true; 
    VarFull::setValue!True ->
    --consumed = false;
    VarConsumed::setValue!False ->
    --notifyAll()
    Monitor::notifyAll(me);
    --while(!consumed && nanoTime-start <  durationNS) 
    --    waitUntil(end)
    whileWaitUntil(me,end,\ktrue,kfalse @
      VarConsumed::getValue?consumed ->
      VarNanoTime::getValue?now ->
      if not consumed and now<end then ktrue else kfalse
    );
    --if(!consumed)
    VarConsumed::getValue?consumed1 ->
    if not consumed1 then (
      --assert(nanoTime-start >= durationNS);
      --consumed = true 
      VarConsumed::setValue!True ->
      --full = false;
      VarFull::setValue!False ->
      --notifyAll();
      Monitor::notifyAll(me);
      --false
      Return!me!(SendReturn.False) ->
      SKIP
    )else(
      --full = false;
      VarFull::setValue!False ->
      --notifyAll();
      Monitor::notifyAll(me);
      --true
      Return!me!(SendReturn.True) ->
      SKIP
    )
  );SKIP

receiveWithin(me,duration)=
  Call!me!(RecvParam.duration) ->
  --synchronized
  Monitor::enter(me);
  --val start = nanoTime
  VarNanoTime::getValue?start ->
  --val end = start+durationNS
  let end=start+duration within
  --while(!full && nanoTime-start < durationNS) 
  --  waitUntil(end)
  whileWaitUntil(me,end,\ktrue,kfalse @
    VarFull::getValue?full ->
    VarNanoTime::getValue?now ->
    if not full and now<end then ktrue else kfalse
  );
  --if(!full)
  VarFull::getValue?full ->
  if(not full) then (
    --assert(nanoTime-start >= durationNS); 
    --None
    Return!me!(RecvReturnNone) ->
    SKIP
  )else(
    --full = false;
    VarFull::setValue!false ->
    --notifyAll; 
    Monitor::notifyAll(me);
    --Some(data)
    VarData::getValue?data ->
    Return!me!(RecvReturn.data) ->
    SKIP
  )


runWith(hideSpurious, hideInternal, p) =
  Monitor::runWith(hideSpurious, hideInternal,
  VarNanoTime::runWith(hideInternal,
  VarData::runWith(hideInternal,
  VarFull::runWith(hideInternal,
  VarConsumed::runWith(hideInternal,
    p ||| clock(0)
  )))))