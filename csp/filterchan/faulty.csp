module VariableMin(TypeValue, initialValue)
  Var(value) =
    getValue!value -> Var(value)
    [] 
    setValue?value -> Var(value)
  
  chanset = {|
    getValue, setValue
  |}

exports
  runwith(hide,P) = 
    if hide then (Var(initialValue) [| chanset |] P) \ chanset
    else Var(initialValue) [| chanset |] P
  
  channel getValue, setValue: TypeValue
endmodule


module ModuleMonitor(TypeThreadID)
  channel
    Notify, NotifyAll, Exit, Wait,
    WaitNotify, WaitEnter,
    MonitorWake, SpuriousWake: TypeThreadID

  chanset = {|
    Notify, NotifyAll, Exit, Wait,
    WaitNotify, WaitEnter,
    MonitorWake, SpuriousWake
  |}

  repeat(ch, s) =
    if s=={} then SKIP
    else ch?a:s -> repeat(ch, diff(s, {a}))

  active(cur, waiting) =
    --current running thread notify
    Notify.cur -> (
      if waiting=={} then 
        --do nothing if no thread is waiting
        active(cur, {})
      else
        --wakeup a process
        MonitorWake?a:waiting -> 
        active(cur, diff(waiting, {a}))
    ) []
    --current running thread notifyAll
    NotifyAll.cur -> (
      repeat(WaitNotify, waiting);
      active(cur, {})
    ) []
    --current running thread exit
    Exit.cur -> (
      inactive(waiting)
    ) []
    --current running thread wait
    Wait.cur -> (
      inactive(union(waiting,{cur}))
    ) []
    waiting!={} & SpuriousWake?a:waiting -> (
      active(cur, diff(waiting, {a}))
    )

  inactive(waiting) = 
    WaitEnter?a -> (
      active(a, waiting)
    ) []
    waiting!={} & SpuriousWake?a:waiting -> (
      inactive(diff(waiting, {a}))
    )

exports
  runwith(hide,P) = 
    if hide then (inactive({}) [|chanset|] P) \ chanset
    else inactive({}) [|chanset|] P

  --java-like synchronized function
  synchronized(me, P)=
    WaitEnter.me ->
    P;
    Exit.me ->
    SKIP

  --notify()
  notify(me) = 
    Notify.me ->
    SKIP
  --notifyAll()
  notifyAll(me) =
    NotifyAll.me ->
    SKIP
  --exit()
  exit(me) =
    Exit.me ->
    SKIP
  --wait()
  wait(me) =
    Wait.me -> ((
        WaitNotify.me ->
        WaitEnter.me ->
        SKIP
      ) [] (
        SpuriousWake.me ->
        WaitEnter.me ->
        SKIP
      )
    )
  --while(cond) wait()
  --typeof(cond) = (ktrue, kfalse) -> Proc
  whileWait(me,cond) =
    cond(
      --if cond evaluates to true, wait and run loop again
      wait(me);whileWait(me, cond), 
      --if cond evaluates to false, exit
      SKIP
    )
endmodule

--Def thread
datatype TypeThreadID = S1 | S2 | R1 | R2
datatype TypeData = A | B
isA(x) = x==A
isB(x) = x==B

instance Monitor = ModuleMonitor(TypeThreadID)
instance Full = VariableMin(Bool, False)
instance Data = VariableMin(TypeData, A)
--------- A generic variable

--------- Filter Chan
channel sendStart, receiveReturn: TypeThreadID. TypeData

send(me, x) = Monitor::synchronized(me,
  --line1
  Monitor::whileWait(me, \ktrue,kfalse @
    Full::getValue?full ->
    if full then ktrue else kfalse
  );
  --line2
  Data::setValue!x ->
  Full::setValue!True ->
  sendStart.me.x -> 
  Monitor::notifyAll(me);
  --line3
  Monitor::whileWait(me, \ktrue,kfalse @
    Full::getValue?full ->
    if full then ktrue else kfalse
  )
)

receive(me, p) = Monitor::synchronized(me,
  --line1
  Monitor::whileWait(me, \ktrue,kfalse @
    Full::getValue?full ->
    Data::getValue?data ->
    if (not full) then ktrue else kfalse
  );
  --line2
  Full::setValue!False ->
  Data::getValue?result ->
  receiveReturn!me!result -> 
  --line3
  Monitor::notifyAll(me)
)

repeat(P) = P; repeat(P)

hide=True

System1 = 
  Monitor::runwith(hide,
  Full::runwith(hide,
  Data::runwith(hide,
    send(S1,A) |||
    send(S2,B) ||| 
    receive(R1,isA) |||
    receive(R2,isB)
  )))

spec1 = 
  sendStart.S1.A -> receiveReturn.R1.A -> sendStart.S2.B -> receiveReturn.R2.B -> STOP []
  sendStart.S2.B -> receiveReturn.R2.B -> sendStart.S1.A -> receiveReturn.R1.A -> STOP

assert System1 :[deadlock free]
--Fails because of repetitive spurious wakeup

assert spec1 [T= System1
assert System1 [T= spec1

System2 = 
  Monitor::runwith(hide,
  Full::runwith(hide,
  Data::runwith(hide,
    repeat(send(S1,A)) |||
    repeat(send(S2,B)) ||| 
    repeat(receive(R1,isA)) |||
    repeat(receive(R2,isB))
  )))



spec2 = 
  sendStart.S1.A -> receiveReturn.R1.A -> spec2 []
  sendStart.S2.B -> receiveReturn.R2.B -> spec2

assert spec2 [T= System2
assert System2 [T= spec2