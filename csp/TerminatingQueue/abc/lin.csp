channel Sync: TypeThread.TypeCallParam.TypeReturnParam
channel SyncShutDown
Lin(All,me)=(
  Call!me?enqueueCallObj:{|EnqueueCall|} ->
  Sync!me!enqueueCallObj!EnqueueReturn ->
  Return!me!EnqueueReturn ->
  Lin(All,me)
) [] (
  Call!me!DequeueCall -> ((
    --Only return None when all linearizers reach here
    --introduce another channel
    SyncShutDown ->
    --Without introducing another channel, but add Sync.anyThread.DequeueCall.DequeueReturnNone to linEvents
    Sync?t.DequeueCall.DequeueReturnNone ->
    Return!me!(DequeueReturnNone) ->
    STOP
  )[](
    Sync!me!DequeueCall?EnqueueReturnObj:{|DequeueReturn|} ->
    Return!me!EnqueueReturnObj ->
    Lin(All,me)  
  ))
)
LinEvents(All,me)={|Sync.me,Call.me,Return.me,SyncShutDown|}
Linearizers(All)=((|| me: All @ [LinEvents(All,me)] Lin(All,me)) [|{|Sync|}|] spec1) \ {|Sync,SyncShutDown|}
Linearizers1(All)=((|| me: All @ [LinEvents(All,me)] Lin(All,me)) [|{|Sync|}|] spec1)

--not enqueued, allow a enqueue, b enqueue, a dequeue or fail dequeue
--enqueued, not dequeued, allow enqueue of c, dequeue of a, dequeue of b, dequeue not fail
--enqueued and dequeue, enqueue of c, dequeue of c

--When queue is in the form of A*
spec1=(
  --A thread calls enqueue(A)
  Sync?t!(EnqueueCall.A)!(EnqueueReturn) -> spec1
)[](
  --A thread calls enqueue(B)
  --Now the queue is in the form of A*BC^0
  Sync?t!(EnqueueCall.B)!(EnqueueReturn) -> spec2
)[](
  --A thread calls dequeue(), and get A
  Sync?t!(DequeueCall)!(DequeueReturn.A) -> spec1
)[](
  --A thread calls dequeue(), and fails
  Sync?t!(DequeueCall)!(DequeueReturnNone) -> spec4
)

--When queue is in the form of A*BC*
spec2=(
  --A thread calls enqueue(C)
  Sync?t!(EnqueueCall.C)!(EnqueueReturn) -> spec2
)[](
  --A thread calls dequeue() and returns A
  Sync?t!(DequeueCall)!(DequeueReturn.A) -> spec2
)[](
  --A thread calls dequeue() and returns B
  --After this operation, the queue is now of the form C*
  Sync?t!(DequeueCall)!(DequeueReturn.B) -> spec3
)

--When the queue is in the form of C*
spec3=(
  --A thread calls enqueue(C)
  Sync?t!(EnqueueCall.C)!(EnqueueReturn) -> spec3
)[](
  --A thread calls dequeue() and returns C
  Sync?t!(DequeueCall)!(DequeueReturn.C) -> spec3
)[](
  --A thread calls dequeue(), and fails
  Sync?t!(DequeueCall)!(DequeueReturnNone) -> spec4
)

--When one thread calls dequeue and returns with failure
spec4=RUN({ Sync.t.(DequeueCall).(DequeueReturnNone) | t <- TypeThread })