module ModuleMonitor(TypeThreadID)
  channel
    Notify, NotifyAll, Exit, Wait,
    WaitNotify, WaitEnter,
    MonitorWake, SpuriousWake

  chanset = {|
    Notify, NotifyAll, Exit, Wait,
    WaitNotify, WaitEnter,
    MonitorWake, SpuriousWake
  |}

  repeat(e, n) =
    if n==0 then SKIP
    else e -> repeat(e, n-1)

  active(nwaiting) = 
    --current running thread notify
    Notify -> (
      if nwaiting==0 then 
        --do nothing if no thread is waiting
        active(0)
      else
        --wakeup a process
        MonitorWake -> 
        active(nwaiting-1)
    ) []
    --current running thread notifyAll
    NotifyAll -> (
      repeat(WaitEnter, nwaiting);
      active(0)
    ) []
    --current running thread exit
    Exit -> (
      inactive(nwaiting)
    ) []
    --current running thread wait
    Wait -> (
      inactive(nwaiting+1)
    ) []
    nwaiting>0 & SpuriousWake -> (
      active(nwaiting-1)
    )

  inactive(nwaiting) =
    WaitEnter -> (
      active(nwaiting-1)
    ) []
    nwaiting!=0 & SpuriousWake -> (
      inactive(nwaiting-1)
    )

exports
  runwith(hide,P) = 
    if hide then (inactive({}) [|chanset|] P) \ chanset
    else inactive({}) [|chanset|] P

  --java-like synchronized function
  synchronized(me, P)=
    WaitEnter ->
    P;
    Exit ->
    SKIP

  --notify()
  notify(me) = 
    Notify ->
    SKIP
  --notifyAll()
  notifyAll(me) =
    NotifyAll ->
    SKIP
  --exit()
  exit(me) =
    Exit ->
    SKIP
  --wait()
  wait(me) =
    Wait -> ((
        WaitNotify ->
        WaitEnter ->
        SKIP
      ) [] (
        SpuriousWake ->
        WaitEnter ->
        SKIP
      )
    )
  --while(cond) wait()
  --typeof(cond) = (ktrue, kfalse) -> Proc
  whileWait(me,cond) =
    cond(
      --if cond evaluates to true, wait and run loop again
      wait(me);whileWait(me, cond), 
      --if cond evaluates to false, exit
      SKIP
    )
endmodule