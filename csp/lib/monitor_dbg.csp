module ModuleMonitor(TypeThreadID)
  channel
    Notify, NotifyAll, Exit, Wait,
    WaitNotify, WaitEnter,
    MonitorWake, SpuriousWake: TypeThreadID

  chanset = {|
    Notify, NotifyAll, Exit, Wait,
    WaitNotify, WaitEnter,
    MonitorWake, SpuriousWake
  |}

  repeat(ch, s) =
    if s=={} then SKIP
    else ch?a:s -> repeat(ch, diff(s, {a}))

  --cur is current active running thread
  --waiting is a set of threads waiting to be notified
  active(cur, waiting) =
    --current running thread notify
    Notify.cur -> (
      if waiting=={} then 
        --do nothing if no thread is waiting
        active(cur, {})
      else
        --wakeup a process
        MonitorWake?a:waiting -> 
        active(cur, diff(waiting, {a}))
    ) []
    --current running thread notifyAll
    NotifyAll.cur -> (
      repeat(WaitNotify, waiting);
      active(cur, {})
    ) []
    --current running thread exit
    Exit.cur -> (
      inactive(waiting)
    ) []
    --current running thread wait
    Wait.cur -> (
      inactive(union(waiting,{cur}))
    ) []
    --spurious wakeup
    waiting!={} & SpuriousWake?a:waiting -> (
      active(cur, diff(waiting, {a}))
    )

  --when no active thread is running
  inactive(waiting) = 
    --pick a thread that is ready to enter
    WaitEnter?a -> (
      active(a, waiting)
    ) []
    --spurious wakeup
    waiting!={} & SpuriousWake?a:waiting -> (
      inactive(diff(waiting, {a}))
    )

exports
  --Given a process that uses the monitor
  --Return the process synchronized with the monitor server process
  --If hide is true, monitor channels are hidden
  runwith(hide,P) = 
    if hide then (inactive({}) [|chanset|] P) \ chanset
    else inactive({}) [|chanset|] P

  --java-like synchronized function
  synchronized(me, P)=
    WaitEnter.me ->
    P;
    Exit.me ->
    SKIP
  --notify()
  notify(me) = 
    Notify.me ->
    SKIP
  --notifyAll()
  notifyAll(me) =
    NotifyAll.me ->
    SKIP
  --exit()
  exit(me) =
    Exit.me ->
    SKIP
  --wait()
  wait(me) =
    Wait.me -> ((
        WaitNotify.me ->
        WaitEnter.me ->
        SKIP
      ) [] (
        SpuriousWake.me ->
        WaitEnter.me ->
        SKIP
      )
    )
  --while(cond) wait()
  --typeof(cond) = (ktrue, kfalse) -> Proc
  whileWait(me,cond) =
    cond(
      --if cond evaluates to true, wait and run loop again
      wait(me);whileWait(me, cond), 
      --if cond evaluates to false, exit
      SKIP
    )
endmodule