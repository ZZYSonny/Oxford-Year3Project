include "correct.csp"
hide = True

channel Sync: TypeThreadID. TypeData. TypeData. TypeThreadID. TypeData. TypeData
-- Thread1: thread identity, function parameter, function return
-- Thread2: thread identity, function parameter, function return

-- Spec Process
Spec = Sync?ta?aparam?areturn?tb:diff(TypeThreadID,{ta})!areturn!aparam -> Spec

--linearizer for one process
linearizer(All,ta)=
  Call!ta?aparam -> ((
      --guess a return value for this call, guess another function call to be synchronized with this
      Sync!ta!aparam?areturn?tb:diff(All,{ta})?bparam?breturn ->
      --ta returns
      Return!ta!areturn ->
      linearizer(All,ta)
    )[](
      --the other way round
      Sync?tb:diff(All,{ta})?bparam?breturn!ta!aparam?areturn ->
      Return!ta!areturn ->
      linearizer(All,ta)
  ))
--linearizer which always accept Sync event that does not involve ta
linearizer1(All,ta)=
  linearizer(All,ta) |||
  repeat(Sync?tb:diff(TypeThreadID,{ta})?bparam?breturn?tc:diff(All,{ta})?cparam?creturn->SKIP)
--Generate linearizeres for all process in All Set
linearizers(All)= ([|{|Sync|}|] me:All @ linearizer1(All,me))

--Behavior of each process
--They non-deterministic choose a data to exchange
worker(me) = |~| data:TypeData @ exchange(me,data);worker(me)
--Generate a set of workers
workers(All) = ||| me:All @ worker(me)


--Test for Three threads
All3 = {TA, TB, TC}
System3 = 
  Monitor::runWith(hide,hide,
  Step::runWith(hide,
  Data::runWith(hide,
    workers(All3)
  )))
Spec3 = (linearizers(All3) [|{|Sync|}|] Spec) \ {|Sync|}
assert Spec3 [T= System3
--assert System3 [T= Spec3