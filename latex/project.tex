\documentclass{article}
\begin{document}


\subsection{Converting Scala Program to CSP Model}
\subsubsection{Shared Variable}
//Background - CSP - Example? 

The usage of shared variables is common in concurrent datatypes. For example, some concurrent datatypes may temporarily store an integer value sent by a thread in a variable. However, CSP is more like a functional programming language and does not support mutable variables. 

The behavior of a shared variable can be captured by a recursive function in CSP. The recursive function represents a thread holding the value of variable in the function parameter. At any time, the variable thread is willing to answer a query for the variable value in channel \textbf{getChan}. Or the thread can receive an update on the variable value in channel \textbf{getChan}, after which the function recurses with the new variable value.

//CSP code here

In order for other objects to use the shared variable, the variable function needs to run in parallel with threads, and synchronizing on \textbf{getChan} and \textbf{setChan} events. It is convenient to implement this in a function \textbf{runWith}, to run a process in synchronization with the variable process.

//CSP code here

\subsubsection{Semaphore}



\subsection{Testing Objects}
\subsubsection{ABC}
In the ABC object, three threads are involved in each round of synchronization. On the higher level, three threads call function \textbf{syncA}, \textbf{syncB}, \textbf{syncC} with their parameter respectively, and each function returns the parameters of two other function calls.

The ABC object may be implemented with semaphore. In each round

//feels like a lot of repetition
\begin{itemize}
    \item Initially \textbf{aClear} semaphore is up
    \item A thread calling \textbf{aSync} takes down the \textbf{aClear} semaphore, puts down its value, and raises \textbf{bClear} semaphore, and finally waits for the \textbf{aSignal} semaphore to raise.
    \item Another thread calling \textbf{bSync} takes down the \textbf{bClear} semaphore, put down its value, and raises \textbf{cClear} semaphore, and waits for \textbf{bSignal} semaphore to raise.
    \item One more thread calling \textbf{cSync} takes down the \textbf{cClear} semaphore, put down its value, and raises \textbf{aSignal} semaphore, and waits for \textbf{cSignal} semaphore to raise.
    \item The first thread is able to continue. The thread takes a copy of the other two argument, raises the \textbf{bSignal} thread, and exits with the arguments pair.
    \item The second thread is able to continue and does the similar thing as the first thread. Before exiting, the second thread raises \textbf{cSignal}.
    \item The last thread is then able to continue. Before exiting, the last thread raises \textbf{aClear}, allowing a new round to start.
\end{itemize}

Using the shared variable and semaphore module, it is easy to translate the Scala implementation to a CSP implementation. 

Unlike Monitor in Java and Scala, raising a semaphore immediately allows another thread waiting to \textbf{down} the semaphore to continue. So in the semaphore implementation, it is essential to take a copy of the two other argument, before raising the semaphore for the next thread. 

On the other hand, what if the implementation of \textbf{syncA} does not take a copy of the argument? It turns out the ABC object still works correctly when only three threads are involved, but fails the linearization test with four threads.

\subsubsection{Testing}
Using the standard linearization testing technique, the following channel can be used to represent the synchronization of three threads.
//CSP Code

The first test case involves three thread. Three threads non-deterministically choose a data and then call \textbf{aSync}, \textbf{bSync}, \textbf{cSync}.

The second test case involves four thread. In addition to three threads in the first threads, another thread calling \textbf{aSync} is added.

//CSP Code

When testing with both the correct and the faulty version of ABC object, FDR is able to finish first test case relatively quickly, but requires unacceptable long time for the second test. With further diagnosing the running time of testing, it was found compilation of system specification process took the longest time. 

//TODO: analyze the size of graph



\end{document}