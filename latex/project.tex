\documentclass{article}
\begin{document}


\subsection{Converting Scala Program to CSP Model}
\subsubsection{Shared Variable}
//Background - CSP - Example? 

The usage of shared variables is common in concurrent datatypes. For example, some concurrent datatypes may temporarily store an integer value sent by a thread in a variable. However, CSP is more like a functional programming language and does not support mutable variables. 

The behavior of a shared variable can be captured by a recursive function in CSP. The recursive function represents a thread holding the value of variable in the function parameter. At any time, the variable thread is willing to answer a query for the variable value in channel \textbf{getChan}. Or the thread can receive an update on the variable value in channel \textbf{getChan}, after which the function recurses with the new variable value.

//CSP code here

In order for other objects to use the shared variable, the variable function needs to run in parallel with threads, and synchronizing on \textbf{getChan} and \textbf{setChan} events. It is convenient to implement this in a function \textbf{runWith}, to run a process in synchronization with the variable process.

//CSP code here

\subsubsection{Semaphore}



\subsection{Testing Objects}
\subsubsection{ABC}
In the ABC object, three threads are involved in each round of synchronization. On the higher level, three threads call function \textbf{syncA}, \textbf{syncB}, \textbf{syncC} with their parameter respectively, and each function returns the parameters of two other function calls.

The ABC object may be implemented with semaphore. In each round

//feels like a lot of repetition
\begin{itemize}
    \item Initially \textbf{aClear} semaphore is up
    \item A thread calling \textbf{aSync} takes down the \textbf{aClear} semaphore, puts down its value, and raises \textbf{bClear} semaphore, and finally waits for the \textbf{aSignal} semaphore to raise.
    \item Another thread calling \textbf{bSync} takes down the \textbf{bClear} semaphore, put down its value, and raises \textbf{cClear} semaphore, and waits for \textbf{bSignal} semaphore to raise.
    \item One more thread calling \textbf{cSync} takes down the \textbf{cClear} semaphore, put down its value, and raises \textbf{aSignal} semaphore, and waits for \textbf{cSignal} semaphore to raise.
    \item The first thread is able to continue. The thread takes a copy of the other two argument, raises the \textbf{bSignal} thread, and exits with the arguments pair.
    \item The second thread is able to continue and does the similar thing as the first thread. Before exiting, the second thread raises \textbf{cSignal}.
    \item The last thread is then able to continue. Before exiting, the last thread raises \textbf{aClear}, allowing a new round to start.
\end{itemize}

Using the shared variable and semaphore module, it is easy to translate the Scala implementation to a CSP implementation. 

Unlike Monitor in Java and Scala, raising a semaphore immediately allows another thread waiting to \textbf{down} the semaphore to continue. So in the semaphore implementation, it is essential to take a copy of the two other argument, before raising the semaphore for the next thread. 

On the other hand, what if the implementation of \textbf{syncA} does not take a copy of the argument? It turns out the ABC object still works correctly when only three threads are involved, but fails the linearization test with four threads.

\subsubsection{Testing}
Using the standard linearization testing technique, the following channel can be used to represent the synchronization of three threads.
//CSP Code




\end{document}