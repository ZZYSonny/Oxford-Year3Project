\documentclass{article}
\usepackage{cite}
\usepackage{listing}
\usepackage{csp}
\usepackage{cspm}
\usepackage{helper}

\makeatletter
\AtBeginDocument{%
  \let\c@figure\c@lstlisting
  \let\thefigure\thelstlisting
  \let\ftype@lstlisting\ftype@figure % give the floats the same precedence
}
\makeatother
\renewcommand\floatpagefraction{0.1}

\begin{document}
\section{Summary}
Concurrent datatypes are convenient tools for programmers. With concurrent datatypes, programmers can write code with multiple threads as if they are writing a single-threaded code. However, it is crucial to know the correctness of concurrent datatypes. In this thesis, we present CSP models for common concurrent primitive according to their behaviours. We then systematically build several concurrent datatypes from their Scala sources. We make assertions of these concurrent datatypes with a technique derived from linearizability testing. We find these assertions can effectively find bugs in a concurrent datatype and provide a history to give more context for the developer. 

\newpage
\section{Introduction}
%What is a concurrent datatype
A concurrent datatype offers encapsulation of concurrency and makes writing concurrent programs simpler. With the concurrent datatype, programmers can write code with multiple threads as if they are writing a single-threaded code. 

%Example
The MenWomen object is one of the concurrent objects. The object captures a classical synchronization problem, in which some processes need to pair with other processes by exchanging their identities. Figure \ref{menwomen.scala.interface} is an interface of a concurrent datatype for the MenWomen problem. 

\begin{scalainline}{menwomen.scala.interface}{Interface of a MenWomen object}
  trait MenWomenT{
    def manSync(me: Int): Int
    def womanSync(me: Int): Int
  }
\end{scalainline}

It is vital to know the correctness of the concurrent datatype. If the implementation of the concurrent datatype is wrong, a programmer's code using the implementation will also be buggy. 

There are two main properties to check for a concurrent datatype, the safety property and the liveness property. The safety property states that the behaviour of the concurrent object should observe some invariant. For example, if a process with identity $1$ calling \CSPM{manSync} returns $2$, then the process with identity $2$ should call \CSPM{womanSync} and return $1$. The liveness property states that the concurrent object should not refuse to synchronize when synchronization is possible between one or more processes. For example, a system with one process calling \CSPM{manSync} and one process calling \CSPM{womanSync} should not deadlock.

In this paper, we examine the above two correctness properties for various concurrent datatypes. In addition, we provide a few CSP implementations for objects commonly used in concurrent programming, which can be used in future CSP projects.

\subsection{Linearization test}
%Describe lin point
To verify the correctness of a concurrent datatype, one can carry out the Linearization test described in the paper Testing for Linearizability \cite{linearizability-testing}. The linearization testing framework measures each call's starting and returning time to get a history of function calls and returns. Then for the observed history, the testing framework attempt to find a series of synchronization point that obeys the safety property. The concurrent datatype implementation is considered buggy if the framework can not find a valid synchronization point series. 

In this remaining section we shall look at a few history from the \CSPM{MenWomen} object. The timeline in Figure \ref{menwomen.timeline.simple} visualizes the function call history of two process \CSPM{T1} and \CSPM{T2}. \CSPM{T1} first calls \CSPM{manSync}, then T2 calls \CSPM{womanSync}. A synchronization occurs between \CSPM{T1} and \CSPM{T2}. \CSPM{T1} returns the identity of process \CSPM{T2} then \CSPM{T2} returns the identity of process \CSPM{T1}.
\svginline{menwomen.timeline.simple}{Visualized history of T1 calling manSync and T2 calling womanSync}

In Figure \ref{menwomen.timeline.dead}, both processes calls \CSPM{manSync}, and no synchronization is possible. Note that the liveness condition is not invalidated even if the system deadlocks in this case.
\svginline{menwomen.timeline.dead}{Visualized history of both T1 and T2 calling womanSync}

Scheduling is one of the reasons validating a history can be complicated. In Figure \ref{menwomen.timeline.deschedule}, process \CSPM{T3} calls \CSPM{manSync} first but gets descheduled. Then \CSPM{T1} calls \CSPM{manSync} and synchronizes with \CSPM{T2} which later calls \CSPM{womanSync}. The linearization framework usually needs to search a large state to find a valid series of synchronization points. 
\svginline{menwomen.timeline.deschedule}{Visualized history of T3 get descheduled}

\subsection{Checking safety property using CSP} 
The history can be captured as a trace of a CSP system. In addition to performing the function body, each function call sends a \CSPM{Call} event before the function body and a \CSPM{Return} event after the function body. Figure \ref{common.callreturn} is the definition of \CSPM{Call} and \CSPM{Return} channel in CSP. The definition of the channel usually needs to include all the identity of the calling process, the function called, and its parameter. 

\begin{cspinline}{common.callreturn}{Definition of Call and Return channel}
--identity of the calling process
--function called by the process
channel Call : TypeThreadID.TypeOps
--identity of the calling process
--function called by the process
--return value of the function call
channel Return: TypeThreadID.TypeOps.TypeThreadID
\end{cspinline}

To check the safety property, we check that a testing system built from some processes using the concurrent datatype refines a specification process built from the object definition in the CSP trace model.

A generic and scalable system is used for the testing system to generate possible histories of processes using concrete datatype. Each process in the testing system can call any function from the concurrent object with any arguments allowed. Each process must be allowed to terminate. Otherwise, the testing system only models a system that runs forever, given that there is no deadlock. We shall see how this affects bug finding in a concurrent datatype in later objects.

The specification generates all valid histories. The process uses the same number of linearizer processes synchronizing on events from the \CSPM{Sync} channel. Event from the \CSPM{Sync} channel should include information from all participating processes, and Figure \ref{common.sync} is the \CSPM{Sync} channel definition for ... Each linearizer process repeatedly calls a function, synchronize with zero or some processes, and returns according to the calling argument and extra information from the synchronization point. To match the definition of the generic and scalable testing system, each linearizer process can also choose to terminate. 

\begin{cspinline}{common.sync}{Definition of Sync channel}
--Identity of thread calling ManSync
--Return of ManSync
--Identity of thread calling WomanSync
--Return of WomanSync
channel Sync: TypeThreadID.TypeThreadID.TypeThreadID.TypeThreadID
\end{cspinline}
  
We shall see a concrete testing system and specification process in the MenWomen section. 

\subsection{Checking liveness property using CSP}
For liveness property, we check the same generic and scalable testing system refines the same specification process, but in the failure model. Suppose all process calls \CSPM{manSync}. Since a linearizer process calling \CSPM{manSync} sends \CSPM{Return} event only after synchronizing \CSPM{Sync} event with another linearizer process calling \CSPM{womanSync}, the linearizer will refuse to return any function call, which is a expected behavior. One can use a datatype-specific specification process that does not explicitly use any synchronization points. However, reusing the linearizer process is easier. 

\subsection{Related work}
Testing for Linearizability \cite{linearizability-testing} presents a framework to test concurrent datatypes based on observation of histories. The drawback of this method is that it is unlikely to exhaust all possible histories of a system. 

There are also runtime programming tools to detect bugs in concurrent datatypes and as well as concurrent code. Thread Sanitizer \cite{threadsanitizer} detects race conditions and deadlocks in C++ and Go.

In Chapter 19 of Understanding Concurrent Systems \cite{ucs-book}, the author describes a CSP model for shared variables and provides a tool to analyze shared variable programs. But the tool lacks support for objects frequently used in concurrent programming, such as monitors and semaphores.

\section{Common Objects}
\subsection{Shared Variable}
The usage of shared variables is common in concurrent datatypes. For example, some concurrent datatypes may temporarily store the identity of a waiting process. However, CSP is more like a functional programming language and does not support mutable variables. 

A recursive process in CSP can capture the behaviour of a shared variable. The recursive process holds the value of the variable in its parameter. At any time, the variable process is willing to answer a query for the variable value in channel \CSPM{getValue}. Alternatively, the process can receive an update on the variable value in channel \CSPM{getValue}, after which the function recurses with the new variable value.

Because it is natural for a concurrent datatype to use multiple shared variables, the global variable is implemented as a CSP module in Figure \ref{globalvar.csp} to allow better code reuse. The module requires two parameters. \CSPM{TypeValue} is the set of possible values for the variable, and \CSPM{initialValue} is the value before any process modifies the variable. An uninitialized variable module is also available in the same Figure \ref{globalvar.csp}, with the only difference that the variable non-deterministically chooses an initial value from \CSPM{TypeValue} at start time. \CSPM{runWith} is a convenient helper function to run a given process \CSPM{P} with the \CSPM{Var} process. If the parameter \CSPM{hide} is true, \CSPM{runWith} function hides all events introduced by the shared variable. In later chapters, we will see how the \CSPM{runWith} function helps reduce the code complexity of the synchronization object implementation.

\begin{cspfloat}{globalvar.csp}{The shared variable module in CSP}
--set of possible value for the variable
--inital value for the variable
module ModuleVariable(TypeValue, initialValue)
  Var(value) = getValue!value -> Var(value)
             [] setValue?value -> Var(value)
  chanset = {|getValue, setValue|}
exports
  --(Bool, Proc) -> Proc
  runWith(hide,P) = if hide then (Var(initialValue) [|chanset|] P) \ chanset
                            else  Var(initialValue) [|chanset|] P
  channel getValue, setValue: TypeValue
endmodule

module ModuleUninitVariable(TypeValue)
  Var(value) = getValue!value -> Var(value)
            [] setValue?value -> Var(value)
  chanset = {|getValue, setValue|}
exports
  runWith(hide,P) = 
    if hide then ((|~| x:TypeValue @ Var(x)) [| chanset |] P) \ chanset
    else (|~| x:TypeValue @ Var(x)) [| chanset |] P
  channel getValue, setValue: TypeValue
endmodule
\end{cspfloat}

Figure \ref{globalvar.csp.example} is an example of two processes using a shared variable. The first line in the example creates a shared variable \CSPM{VarA} with value ranging from $0$ to $2$ and initialized with $0$. Process \CSPM{P} increments \CSPM{VarA} modulo $3$ forever and process \CSPM{Q} reads \CSPM{VarA} forever. Process \CSPM{P} interleaves with process \CSPM{Q}, and the combined process is further synchronized with the variable \CSPM{VarA} process. In the resulting process \CSPM{System}, changes to \CSPM{VarA} made by process \CSPM{P} is visible to process \CSPM{Q}.

\begin{cspinline}{globalvar.csp.example}{Example of two processes using a shared variable}
instance VarA = ModuleVariable({0..2},0)
P = VarA::getValue?a -> VarA::setValue!((a+1)%3) -> P
Q = VarA::getValue?a -> Q
System = VarA::runWith(false,P|||Q)
\end{cspinline}


\subsection{Semaphore}
A Semaphore is a simple but powerful concurrent primitive. This thesis shall describe and use a simplified binary semaphore from [TODO: Reference], which removes interrupts and timeout operations. 

A binary semaphore can either be raised or lowered. A \CSPM{down} function call raises the semaphore regardless of the semaphore state. If a process calls the \CSPM{down} method when the semaphore is raised, the semaphore becomes unraised. However, if the semaphore is unraised, the process waits until another process calls \CSPM{up} and proceeds to put down the semaphore. Depending on the initial state of the semaphore, a binary semaphore can be further categorized as a mutex semaphore or a signalling semaphore.

Modelling a semaphore is simple in CSP. A process may call \CSPM{up} function or \CSPM{down} function via channel \CSPM{upChan} or channel \CSPM{downChan} respectively. The semaphore is modelled by a process implemented by two mutually recursive functions \CSPM{Semaphore(True)} and \CSPM{Semaphore(False)}. The semaphore process representing an unraised state accepts a \CSPM{upChan} event by any process and proceeds to the raised process. The semaphore process representing a raised state can either accept a \CSPM{upChan} event and recurse to the raised process, or accept a \CSPM{downChan} event and proceed to the unraised process.

Like the shared variable in the earlier subsection, the semaphore is encapsulated in a CSP module. To create a semaphore, one needs to supply two arguments. \CSPM{TypeThreadID} is the set of identities of processes that use this semaphore. \CSPM{initialState} is a boolean value indicating the starting state of the semaphore. If \CSPM{initialState} is true, the semaphore is raised initially. Otherwise, the semaphore is lowered. 
\begin{cspfloat}{semaphore.csp}{The binary semaphore module in CSP}
module ModuleSemaphore(TypeThreadID, initialState)
  --Raised
  Semaphore(True) = downChan?id -> Semaphore(False)
                   [] upChan?id -> Semaphore(True)
  --Unraised
  Semaphore(False)= upChan?id   -> Semaphore(True)
  
  chanset = {|upChan, downChan|}
exports
  --runWith::(Bool,Proc) -> Proc
  runWith(hide,P) = (Semaphore [| chanset |] P) \ 
                     (if hide then chanset else {})
  channel upChan, downChan: TypeThreadID
endmodule
\end{cspfloat}

\subsection{Monitor}
A Monitor is another powerful concurrent primitive. This thesis will also use a simplified monitor from [TODO:reference].

\begin{scalainline}{monitor.scala.example}{A simple Scala class that uses a monitor internally}
class MonitorExample {
  private var a = 0;
  private var b = 0;

  def op1():Unit = synchronized{ a+=1; }
  def op2():Unit = synchronized{ b+=1;wait();b-=1; }
  def op3():Unit = synchronized{ notify(); }
  def op4():Unit = synchronized{ notifyAll(); }
}
\end{scalainline}

Usually, code protected by the monitor is wrapped inside a \CSPM{synchronized} block. In Figure \ref{monitor.scala.example}, \CSPM{op1} uses synchronized to prevent race condition on the variable \CSPM{a}. To run a \CSPM{synchronized} block in CSPM, the process first needs to synchronize with the monitor process on a \CSPM{waitEnter} event, which works as a certificate to run the code insider \CSPM{synchroninzed} block. After running the code inside \CSPM{synchronized} block, the process sends a \CSPM{Exit} event to notify the monitor process that it is exiting.

Inside a \CSPM{synchronized} block, the process can also perform \CSPM{wait}, \CSPM{notify}, and \CSPM{notifyAll}. The method \CSPM{op2} in Figure \ref{monitor.scala.example} first increments \CSPM{b}, wait to be notified, and decrements \CSPM{b}. So the shared variable \CSPM{b} here counts the number of processes waiting to be notified. The method \CSPM{op3} notifies one waiting process and \CSPM{op4} notifies all waiting processes. 

In the CSP implementation, a waiting process first synchronizes a \CSPM{Wait} event with the monitor process to indicate that the process calls \CSPM{wait} and no longer holds the running certificate. The process can then be waked up with \CSPM{waitNotify} or spuriously by an event \CSPM{SpuiousWake} from the monitor process. Finally, the process needs to reobtain the certificate \CSPM{WaitEnter} to resume execution. In practice, the \CSPM{wait} function is often guarded with a while loop to prevent spurious wakeup. Again CSPM does not have a built-in while loop, and a generic while statement is implemented in continuation pass style. (Maybe leave this continuation pass style while loop in appendix?)

Note that both \CSPM{WaitNotify} and \CSPM{SpuriousWake} events come from the monitor process. When a process calls \CSPM{notify} or \CSPM{notifyAll}, it needs to synchronize with the monitor process. \CSPM{notify} and \CSPM{notifyAll} are implemented in this way because usually, a process does not know how many processes are waiting. If a process calling \CSPM{notify} synchronizes directly with a waiting process, then the notifying process will block if there is no waiting process. Similarly, a process calling \CSPM{notifyAll} does not know how many processes it should wake up. 

The monitor process has two states. The monitor process allows a different set of events in two different states. When there is no running process, the monitor can allow a free process to enter its synchronized block by synchronizing on a \CSPM{waitEnter} event with the process. When there is a running process, the monitor process should respond to method calls from the running process, but the monitor should not allow another process to obtain the monitor lock. In either state, the monitor process can spuriously wake up a waiting process.

It is note worthing that a monitor can create divergence in CSP under convention of linearization tests. The monitor can spuriously wake up a process waiting. The process wakes up, find the condition unsatisfied, and waits again. These are all $\tau$ event in the testing system, since non of these events are \CSPM{Call} and \CSPM{Return} event. To solve the problem, the monitor supports disabling spurious wake up with the parameter \CSPM{disableSpurious}.

//Should I split some functions into respective paragraphs here. Or use line number. 
\begin{cspfloat}{monitor.csp.1}{The CSP monitor module - private part}
module ModuleMonitor(TypeThreadID, disableSpurious)
  channel
    Notify, NotifyAll, Exit, Wait,
    WaitNotify, WaitEnter, SpuriousWake: TypeThreadID

  chanset = {| Notify, NotifyAll, Exit, Wait, WaitNotify, WaitEnter, SpuriousWake|}

  --A list of event for every event e in s
  repeat(ch, s) =
    if s=={} then SKIP
    else ch?a:s -> repeat(ch, diff(s, {a}))

  --cur is current active running thread
  --waiting is a set of threads waiting to be notified
  active(cur, waiting) =
    --current running thread notify
    Notify.cur -> (
      if waiting=={} then 
        --do nothing if no thread is waiting
        active(cur, {})
      else
        --wakeup a process
        WaitNotify?a:waiting -> 
        active(cur, diff(waiting, {a}))
    ) []
    --current running thread notifyAll
    NotifyAll.cur -> (
      repeat(WaitNotify, waiting);
      active(cur, {})
    ) []
    --current running thread exit
    Exit.cur -> (
      inactive(waiting)
    ) []
    --current running thread wait
    Wait.cur -> (
      inactive(union(waiting,{cur}))
    ) []
    --spurious wakeup
    waiting!={} & SpuriousWake?a:waiting -> (
      active(cur, diff(waiting, {a}))
    )

  --when no active thread is running
  inactive(waiting) = 
    --pick a thread that is ready to enter
    WaitEnter?a -> (
      active(a, waiting)
    ) []
    --spurious wakeup
    waiting!={} & SpuriousWake?a:waiting -> (
      inactive(diff(waiting, {a}))
    )
\end{cspfloat}
\begin{cspfloat}{monitor.csp.2}{The CSP monitor module - public part}
exports
  --Given a process that uses the monitor
  --Return the process synchronized with the monitor server process
  --If hide is true, monitor channels are hidden
  runWith(hideSpurious, hideInternal, P) = 
    let hideset0 = if hideInternal then chanset else {} within
    let hideset1 = if hideSpurious then hideset0 else diff(hideset0,{|SpuriousWake|}) within
    (inactive({}) [|chanset|] P) \ hideset1
  
  --java-like synchronized function
  synchronized(me, P)=
    WaitEnter.me ->
    P;
    Exit.me ->
    SKIP

  enter(me) = 
    WaitEnter.me ->
    SKIP

  exit(me) =
    Exit.me -> 
    SKIP

  --notify()
  notify(me) = 
    Notify.me ->
    SKIP

  --notifyAll()
  notifyAll(me) =
    NotifyAll.me ->
    SKIP

  --wait()
  wait(me) =
    Wait.me -> 
    if disableSpurious then ((
      WaitNotify.me ->
      WaitEnter.me ->
      SKIP
    ) [] (
      SpuriousWake.me ->
      WaitEnter.me ->
      SKIP
    )
  ) else (
      WaitNotify.me ->
      WaitEnter.me ->
      SKIP
  )
  
  whileWait(me,cond) =
    while(cond)(wait(me);SKIP)
endmodule
\end{cspfloat}

\newpage
\section{MenWomen}
For simplicity, a process calling \CSPM{ManSync} is called a man process, and a process calling \CSPM{WomanSync} is called a woman process. 

\subsection{Implementation}
One way to implement the MenWomen object is to use a monitor and a shared variable indicating the stage of synchronization. Figure \ref{menwomen.scala.correct} is a Scala implementation of the MenWomen object with monitor.
\begin{itemize}
  \item A man process enters the synchronization and waits until the current stage is $0$. Then in stage $0$, the man process sets the global variable \CSPM{him} inside the \CSPM{MenWomen} object to its identity. Then the man process notifies all processes so that a waiting woman process can continue. Finally, the man process waits for stage 2.
  \item A women process enters the synchronization and waits until the current stage is $1$. The woman process sets the global variable \CSPM{her} to its identity and returns the value of the global variable \CSPM{him}.
  \item In stage $2$, the waiting man process in stage $0$ is wakened up by the woman process in stage $1$. The man process notifies all waiting processes and returns the value of \CSPM{her}.
\end{itemize}

The code snippet in Figure \ref{menwomen.scala.correct} is a Scala implementation of the MenWomen process using a monitor by Gavin Lowe. With the shared variable and monitor module, the Scala code is further translated to a CSP code in Figure \ref{menwomen.csp.correct}. With the convention described in the introduction section, every function call begins with a Call event containing all parameters. And every function call ends with a Return event containing the return value.

\begin{scalafloat}{menwomen.scala.correct}{A correct MenWomen object implementation in Scala}
class MenWomen extends MenWomenT{
  private var stage = 0
  private var him = -1
  private var her = -1

  def manSync(me: Int): Int = synchronized{
    while(stage != 0) wait()         
    him = me; stage = 1; notifyAll() 
    while(stage != 2) wait()
    stage = 0; notifyAll(); her
  }

  def womanSync(me: Int): Int = synchronized{
    while(stage != 1) wait()
    her = me; stage = 2; notifyAll();
  }
}
\end{scalafloat}

\begin{cspfloat}{menwomen.csp.correct}{Translated CSP code for the correct MenWomen object immplementation}
instance VarStage = ModuleVariable({0,1,2},0) 
instance VarHim = ModuleUninitVariable(TypeThreadID)
instance VarHer = ModuleUninitVariable(TypeThreadID)
instance Monitor = ModuleMonitor(TypeThreadID)
manSync(me) = 
  Call!me!ManSync ->
  Monitor::enter(me);
    Monitor::whileWait(me, \ktrue,kfalse @
      VarStage::getValue?x ->
      if x!=0 then ktrue else kfalse
    );
    VarHim::setValue!me ->
    VarStage::setValue!1 ->
    Monitor::notifyAll(me);
    Monitor::whileWait(me, \ktrue,kfalse @
      VarStage::getValue?x ->
      if x!=2 then ktrue else kfalse
    );
    VarStage::setValue!0 ->
    Monitor::notifyAll(me);
    VarHer::getValue?ans ->(
  Monitor::exit(me);
  Return!me!ManSync!ans->
  SKIP
  )
womanSync(me)=
  Call!me!WomanSync ->
  Monitor::enter(me);
    Monitor::whileWait(me, \ktrue,kfalse @
      VarStage::getValue?x ->
      if x!=1 then ktrue else kfalse
    );
    VarHer::setValue!me ->
    VarStage::setValue!2 ->
    Monitor::notifyAll(me);
    VarHim::getValue?ans ->(
  Monitor::exit(me);
  Return!me!WomanSync!ans->
  SKIP
  )
\end{cspfloat}


\subsection{Linearization Test}
Recall that in the testing system, each process can call any function provided by the concurrent datatype or choose to terminate. In the CSP implementation, a helper function is used. \CSPM{chaosP(P)} runs the process \CSPM{P} that terminate with \CSPM{SKIP} any number of time. With the helper function, the process \CSPM{P} only needs to non-deterministically choose to perform \CSPM{manSync} or \CSPM{womanSync} with its identity.

All processes in the testing system interleave with other processes and synchronize with the processes of shared variables and the process of the monitor. Since the testing system should only include \CSPM{Call} and \CSPM{Return} events, all other events are hidden using the first two boolean flags in \CSPM{runWith} defined in earlier sections. 

\begin{cspinline}{menwomen.csp.testsystem}{Definition of CSP processes in the testing system}
Thread(me)=chaosP(manSync(me) |~| womanSync(me))
System(All)=runWith(True,True,||| me:All @ Thread(me))
\end{cspinline}

Similarly, a linearizer process can non-deterministically choose to perform \CSPM{manSync}, synchronize with another linearizer process calling \CSPM{womanSync}, and return with the identity it received from the \CSPM{Sync} event. Also, the linearizer can choose to call \CSPM{womanSync} or terminate. \CSPM{Linearizers(All)} puts all linearizers processes in parallel. 

The \CSPM{Linearizers} function creates a combined linearizer process in three steps. First, it put all linearizer processes in parallel using Replicated Generalized Parallel in CSPM. Specifically,  General Parallel uses three arguments, the linearizer identity set, the linearizer process, and a synchronization alphabet set. The synchronization alphabet set for a process identity is the set of \CSPM{Sync} events where the process identity appears on the first or the third argument. If a linearizer process wants to send an event in its synchronization alphabet set, it must synchronize with all other linearizer processes whose synchronization alphabet sets include this event. 
Then \CSPM{Linearizers} runs the paralleled process with the specification process of \CSPM{Sync} event. For \CSPM{MenWomen} object, the synchronization is stateless and only requires the return value to be the identity of the other process.
Finally, like the testing system, all \CSPM{Sync} events are hidden to provide all valid histories.

\begin{cspfloat}{menwomen.csp.lin}{Definition of linearizer process in CSP}
Lin(All,me)= (
  Call!me!ManSync->
  Sync!me?mereturn?other?otherreturn ->
  Return!me!ManSync!mereturn ->
  Lin(All,me)
)|~|(
  Call!me!WomanSync ->
  Sync?other?otherreturn!me?mereturn ->
  Return!me!WomanSync!mereturn ->
  Lin(All,me)
)|~|STOP

LinEvents(All,me)=union({
  ev | ev<-{|Sync|},
  let Sync.t1.a.t2.b=ev within
    countList(me,<t1,t2>)==1 and
    member(t1, All) and
    member(t2, All)
},{|Call.me,Return.me|})

Linearizers(All)=((|| me: All @ [LinEvents(All,me)] Lin(All,me)) [|{|Sync|}|] Spec) 
                  \{|Sync|}
\end{cspfloat}

Figure \ref{menwomen.lin.simple} visualizes how the linearizer process can generate the trace that corresponds to the history described in Figure \ref{menwomen.timeline.simple}, where one process calls \CSPM{manSync} and another process calls \CSPM{womanSync}. And \ref{menwomen.lin.dead} visualizes the linearizer deadlocks as required if both processes calls \CSPM{manSync}.

\svginline{menwomen.lin.simple}{Linearizers generating the history where one process calls manSync and another process calling womenSync}
\svginline{menwomen.lin.dead}{Linearizers generating the history where one process calls manSync and another process calling womenSync}

Finally, we perform the test using trace refinement for safety property and failure refinement for liveness. As expected, the correct implementation passes all tests. 
\begin{cspinline}{menwomen.csp.test}{Part of liveness and safetyness test in CSP for MenWomen object}
System2=System({T1,T2})
Spec2Thread=Linearizers({T1,T2})
assert Spec2Thread [T= System2
assert Spec2Thread [F= System2
\end{cspinline}

\subsection{A faulty version}
We shall examine another MenWomen implementation in Figure \ref{menwomen.scala.faulty}. One key difference in this faulty MenWomen object is that it uses \CSPM{Option} data in the shared variables to store the identity of the process calling \CSPM{manSync} and the process calling \CSPM{womanSync}. 

\begin{scalafloat}{menwomen.scala.faulty}{A Faulty Scala implementation of MenWomen object}
class FaultyMenWomen extends MenWomenT{
  private var him: Option[Int] = None
  private var her: Option[Int] = None

  def manSync(me: Int): Int = synchronized{
    while(him.nonEmpty) wait()
    him = Some(me); notifyAll()
    while(her.isEmpty) wait()   
    val Some(res) = her
    her = None; notifyAll()
    res
  }

  def womanSync(me: Int): Int = synchronized{
    while(her.nonEmpty) wait()
    her = Some(me); notifyAll()
    while(him.isEmpty) wait()  
    val Some(res) = him
    him = None; notifyAll()
    res
  }
}
\end{scalafloat}

The safeness property test shows that this implementation handles scheduling carelessly. This implementation fails the test \CSPM{Spec2Thread [T= System2}, and FDR provides a trace that violates the safeness specification, shown in Figure \ref{menwomen.faulty.trace}. FDR further allows the user to expand the hidden $\tau$ events in the testing system, which are normally processes' interactions with shared variables and the monitor. By understanding the expanded trace in CSP, we can find a equivalent way to trigger the bug in Scala.

\svginlinescaled{menwomen.faulty.trace}{0.95}{Trace}

\begin{itemize}
  \item A process \CSPM{T1} calls \CSPM{manSync}. On first line, since the shared variable \CSPM{him} is initially \CSPM{None}, \CSPM{T1} skips the \CSPM{wait}, set \CSPM{him} to \CSPM{Some(T1)} and waits for a process calling \CSPM{womanSync}.
  \item A process \CSPM{T2} calls \CSPM{womanSync} and returns \CSPM{T1}. At this stage, there is no waiting process waiting to run \CSPM{womanSync} and the shared variable is not \CSPM{None}. So \CSPM{T2} does not wait at any point, notifies all waiting process, and returns.
  \item Before \CSPM{T1} reenters the \CSPM{synchronized} block, process \CSPM{T2} calls \CSPM{womanSync} again. \CSPM{him} has not been reset by \CSPM{T1} yet. So \CSPM{T2} pairs with \CSPM{T1} again, which should not be allowed. 
\end{itemize}

\newpage
\section{ABC}
With an ABC object, three processes can exchange data with each other two processes. More specifically, one process calling \CSPM{aSync}, one process calling \CSPM{bSync}, and one process calling \CSPM{cSync} synchronizes. Then each of the three processes returns with the arguments of two other processes. For simplicity, we shall call a process calling \CSPM{syncA} as an A-process, a process calling \CSPM{syncB} as a B-process, and a process calling \CSPM{syncC} as a C-process. 

One of the challenges to check an ABC object is the huge number of states in the CSP model. In this section, we shall see how the linearizer process can be optimized and the efficiency of the explicit linearization point test.

\subsection{Implementation}
Figure \ref{abc.scala.correct} is a Scala implementation of a ABC object with semaphore. In each round of synchronization,
\begin{itemize}
    \item Initially semaphore \CSPM{aClear} is raised. An A-process acquires semaphore \CSPM{aClear}, sets the shared variable \CSPM{a} to its parameter, raises semaphore \CSPM{bClear} and waits to acquire semaphore \CSPM{aSignal}. A B-process and a C-process behaves similarly in turn, except they use different semaphores and shared variables. 
    \item After a C-process raises semaphore \CSPM{aSignal}, the A-process is able to continue. The A-process reads the shared variable \CSPM{b} and \CSPM{c}, raises the semaphore \CSPM{bSignal}, and returns \CSPM{b} and \CSPM{c}. Likewise, B and C also take the value of two other shared variable and raise respective semaphores in turn.
\end{itemize}

Using the shared variable and semaphore module, it is easy to translate the Scala implementation to a CSP implementation.

\begin{scalafloat}{abc.scala.correct}{A semaphore-based Scala implementation of the ABC object}
class ABC[A,B,C] extends ABCT[A,B,C]{
  // The identities of the current (or previous) threads.
  private var a: A = _
  private var b: B = _
  private var c: C = _

  // Semaphores to signal that threads can write their identities.
  private val aClear = MutexSemaphore()
  private val bClear, cClear = SignallingSemaphore()

  // Semaphores to signal that threads can collect their results. 
  private val aSignal, bSignal, cSignal = SignallingSemaphore()

  def syncA(me: A) = {
    aClear.down         // (A1)
    a = me; bClear.up   // signal to b at (B1)
    aSignal.down        // (A2)
    val result = (b,c)
    bSignal.up          // signal to b at (B2)
    result
  }

  def syncB(me: B) = {
    bClear.down         // (B1)
    b = me; cClear.up   // signal to C at (C1)
    bSignal.down        // (B2)
    val result = (a,c)
    cSignal.up          // signal to c at (C2)
    result
  }

  def syncC(me: C) = {
    cClear.down         // (C1)
    c = me; aSignal.up  // signal to A at (A2)
    cSignal.down        // (C2)
    val result = (a,b)
    aClear.up           // signal to an A on the next round at (A1)
    result
  }
}      
\end{scalafloat}

\begin{cspfloat}{abc.csp.correct}{Translated CSP Code for the correct ABC implementation}
instance VarA = ModuleUninitVariable(TypeData) 
instance VarB = ModuleUninitVariable(TypeData)
instance VarC = ModuleUninitVariable(TypeData)

instance aClear = ModuleMutexSemaphore(TypeThreadID)
instance bClear = ModuleSignallingSemaphore(TypeThreadID)
instance cClear = ModuleSignallingSemaphore(TypeThreadID)
instance aSignal = ModuleSignallingSemaphore(TypeThreadID)
instance bSignal = ModuleSignallingSemaphore(TypeThreadID)
instance cSignal = ModuleSignallingSemaphore(TypeThreadID)

runWith(hide,p)=
  VarA::runWith(hide,
  VarB::runWith(hide,
  VarC::runWith(hide,
  aClear::runWith(hide,
  bClear::runWith(hide,
  cClear::runWith(hide,
  aSignal::runWith(hide,
  bSignal::runWith(hide,
  cSignal::runWith(hide,
    p
  )))))))))

SyncA(me,avalue) =
  Call!me!ASync!avalue ->
  --aClear.down
  aClear::downChan!me ->
  --a = me
  VarA::setValue!avalue ->
  --bClear.up
  bClear::upChan!me ->
  --aSignal.down
  aSignal::downChan!me ->
  --(b,c)
  VarB::getValue?b ->
  VarC::getValue?c ->
  --bSignal.up
  bSignal::upChan!me ->
  --result ->
  Return!me!ASync!(b.c) ->
  SKIP

...
\end{cspfloat}

\subsection{Testing}
Similar for the MenWomen object, a testing system is defined through any number of working processes and a specification is built from a \CSPM{Sync} channel, linearizer processes, and a synchronization alphabet set. 

One key difference of the \CSPM{ABC} object is that processes can call with any argument from the set \CSPM{TypeData}, whereas in \CSPM{MenWomen} object, processes can only call with their identity. As shown in Figure \ref{abc.csp.worker} So inside \CSPM{chaosP}, the processes also choose an argument with General Non-Deterministic Choice. 

\begin{cspinline}{abc.csp.worker}{Definition of processes in the testing system.}
Thread(me)=chaosP( |~| x:TypeData @ (
    SyncA(me,x) 
  |~| SyncB(me,x) 
  |~| SyncC(me,x)
))
\end{cspinline}

The testing specification uses the same component, the \CSPM{Sync} channel, linearizer processes, and linEventns. The definition of \CSPM{Sync} channel is shown in Figure \ref{abc.csp.sync}. The event $Sync.t_1.a.b.c.t_2.d.e.f.t_3.g.h.i$ represents the synchronizations between three threads, $t_1,t_2,t_3$. Process $t_1$ calls \CSPM{aSync} with $a$ and returns $(b,c)$. The second process $t_2$ calls \CSPM{bSync} with $d$ and returns $(e,f)$. And the last process $t_3$ calls \CSPM{cSync} with $g$ and returns $(h,i)$. The Sync specification process, shown in the same figure, checks that in each \CSPM{Sync} events, the return value of each process is the pair of arguments of the two other function call. 

Figure \ref{abc.csp.lin} is the definition of a linearizer process, written a similar format with the MenWomen object.

\begin{cspinline}{abc.csp.sync}{Definition of Sync channel and specification of Sync event}
--thread identity calling ASync. ASync parameter a. ASync return pair (b,c)
--thread identity calling BSync. BSync parameter b. BSync return pair (a,c)
--thread identity calling CSync. CSync parameter c. CSync return pair (a,b)
channel Sync: TypeThreadID.TypeData.TypeData.TypeData.
              TypeThreadID.TypeData.TypeData.TypeData.
              TypeThreadID.TypeData.TypeData.TypeData

Spec = Sync?aid?a?b?c
           ?bid:diff(TypeThreadID,{aid})!b!a!c
           ?cid:diff(TypeThreadID,{aid,bid})!c!a!b 
    -> Spec
\end{cspinline}

\begin{cspfloat}{abc.csp.lin}{Definition of linearizer process}
--Linearizer for a process
Lin(All,me)=(
  --me synchronizes as thread A
  Call!me!ASync?a ->
  Sync!me!a?b?c?t2:diff(All,{me})?t2b?t2a?t2c?t3:diff(All,{me,t2})?t3c?t3a?t3b ->
  Return!me!ASync!b!c ->
  Lin(All,me)
) |~| (
  --me synchronizes as thread B
  Call!me!BSync?b ->
  Sync?t2:diff(All,{me})?t2b?t2a?t2c!me!b?a?c?t3:diff(All,{me,t2})?t3c?t3a?t3b ->
  Return!me!BSync!a!c ->
  Lin(All,me)
) |~| (
  --me synchronizes as thread C
  Call!me!CSync?c ->
  Sync?t2:diff(All,{me})?t2b?t2a?t2c?t3:diff(All,{me,t2})?t3a?t3b!me!c?a?b ->
  Return!me!CSync!a!b ->
  Lin(All,me)
)
\end{cspfloat}

\begin{cspinline}{abc.csp.test}{Part of test for ABC object. This tests a system with three processes.}
System3=System({T1,T2,T3})
Spec3Thread=Linearizers({T1,T2,T3})

assert Spec3Thread [T= System3
assert Spec3Thread [F= System3
\end{cspinline}
\subsubsection{Speeding up model compilation}
Consider the specification process with three processes. Let $M$ be the size of the set of all possible arguments. Conside r the trace in Figure \ref{abc.timeline.lin}, where process \CSPM{T1} calls \CSPM{aSync} with \CSPM{A}, \CSPM{T2} calls \CSPM{bSync} with \CSPM{B}, \CSPM{T3} calls \CSPM{cSync} with \CSPM{C}. Then they synchronization.

\svginlinescaled{abc.timeline.lin}{0.95}{The set of possible Sync event for each CSP process}

The last transition in the diagram is the \CSPM{Sync} event between three processes. Above the edge is the set of possible \CSPM{Sync} event that every process accepts. Each linearizer accepts $3^2*M^8$ possible \CSPM{Sync} event. The combined linearizer accepts $M^6$ sync event. However, according to the sync specification, only one \CSPM{Sync} event is valid. 
    
With the above analysis, it is tempting to reduce the redundancy in \CSPM{Sync} event. Optimize the linearizer process by using the information from the specification process. Instead of choosing all possible remaining arguments, the individual linearizer could choose correct arguments according to the specification process. Figure \ref{abc.csp.simple1} includes part of the simplified code. This change does not reduce the number of transitions in the resulting specification, but it helps FDR build the process faster.

With this optimization, the testing for less than 5 processes finishes quickly.

\begin{cspinline}{abc.csp.simple1}{Simplified definition of Sync channel and part of simplified linearizer}
channel Sync: TypeThreadID.TypeThreadID.TypeThreadID.
              TypeData.TypeData.TypeData

Lin(All,me)= (
  Call!me!ASync?a ->
  Sync!me?t2:diff(All,{me})?t3:diff(All,{me,t2})!a?b?c ->
  Return!me!ASync!b!c ->
  Lin(All,me)
) ...
\end{cspinline}

\subsection{Faulty version}
Recall that in Java and Scala, raising a semaphore immediately allows another thread waiting to acquire the semaphore to continue. So it is essential to take a copy of the two other arguments before raising the semaphore.

On the other hand, what if the implementation of \CSPM{syncA} does not take a copy of the argument? It turns out that the faulty \CSPM{ABC} object passes tests for three processes but fails the linearisation test with at least four threads.


\subsubsection{Explanation of the error case}
For the test \CSPM{Spec4Thread [T= System4}, FDR displays a trace of the testing system that violates the specification. From the trace, it seems that process \CSPM{T1} synchronizes with \CSPM{T2} and \CSPM{T3} in the first round, and should return \CSPM{(B,C)}, but \CSPM{(E,F)}, the argument in the second round is returned. Expanding the $\tau$ event and translating CSP traces into program traces makes it possible to see what goes wrong in the faulty version when there are four threads.

\svginlinescaled{abc.faulty.trace}{0.9}{Trace that violates the specification}

\begin{itemize}
  \item In the first round of synchronization, process $T_A$, $T_B$, $T_C$ call \CSPM{aSync}, \CSPM{bSync} or \CSPM{cSync} respectively, and put down its argument in turn.
  \item Process $T_A$ raises \CSPM{bSignal}. Before $T_A$ exits, the other two processes $T_B$, $T_C$ returns. Now $T_A$ should return argument of $T_B$ and $T_C$.
  \item Another round of synchronization starts. Thread $T_D$, $T_B$, $T_C$ call \CSPM{aSync}, \CSPM{bSync} or \CSPM{cSync} respectively, and overwites the shared variable \CSPM{a,b,c} in turn.
  \item Now $T_A$ returns with $(b,c)$ from the second round, which may not be the argument of \CSPM{bSync} and \CSPM{cSync} in the first round.
\end{itemize}

\section{Barrier Counter}
Barrier synchronization is commonly used in concurrent programming ... A barrier object takes an argument $p$. A process calling \CSPM{sync} blocks until all \CSPM{p} processes call \CSPM{sync}. 

This section shall examine a barrier object with an internal counter. When a \CSPM{sync} call exits, it returns the number of times barrier synchronization has happened. 

\subsection{Implementation}

In this section, we shall use a monitor based barrier counter. Additionaly, this implementation uses three shared variables. \CSPM{seqNumber} is the number of synchronization that happened. \CSPM{count} is the number of processes participating in the current round of synchronization and is waiting to return. \CSPM{leaving} indicates if processes are leaving.

There are two stages in each round of synchronization. 
\begin{itemize}
    \item In the first stage, a new process comes and waits for all $p$ processes. Each process increments \CSPM{count}. 
    \item If a process finds the value of \CSPM{count} is $p$ after incrementing \CSPM{count}, the process knows it is the last process in this round. The $p$-th process sets leaving to \CSPM{true} and notifies all waiting processes to allow other processes in this round to leave and blocks any new coming processes. 
    \item In the second stage, all $p$ processes, including the $p$-th process, decrements \CSPM{count} to and returns with the value of the shared variable \CSPM{seqNumber}. 
    \item If a process finds the value of \CSPM{count} equal to $0$, then the process knows it is the last process to leave in this round. Before exiting, it increments \CSPM{seqNumber} and sets \CSPM{leaving} to \CSPM{true}, to allow a new round to start.
\end{itemize}

\begin{scalafloat}{barriercounter.scala.correct}{Implementation of Barrier Counter in Scala} 
class BarrierCounter(n: Int) extends BarrierCounterT{
  private var seqNumber = 0 // the current sequence number
  private var count = 0 // The number of waiting threads.
  private var leaving = false // Are we in the leaving phase?

  def sync = synchronized{
    while(leaving) wait() // Wait for previous round to finish
    count += 1
    if(count == n){ 
      leaving = true; 
      count -= 1; 
      notifyAll(); 
      seqNumber 
    } else{ 
      while(!leaving) wait()
      count -= 1
      if(count == 0){ 
        // Allow next round to continue
        leaving = false; 
        notifyAll() 
        // Increment sequence number for next round
        seqNumber += 1; 
        seqNumber-1 
      }
      else seqNumber
    }
  }
}  
\end{scalafloat}

\subsection{A stateful concurrent datatypes}
\newpage
\section{Terminating Queue}

\section{Reference}
\bibliographystyle{acm}
\bibliography{project}
\end{document}